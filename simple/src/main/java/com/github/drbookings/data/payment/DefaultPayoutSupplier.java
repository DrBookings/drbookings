/*
 * DrBookings
 *
 * Copyright (C) 2016 - 2018 Alexander Kerner
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of the
 * License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-2.0.html>.
 */

package com.github.drbookings.data.payment;

import com.github.drbookings.*;
import com.google.common.collect.Range;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.money.MonetaryAmount;
import java.time.LocalDate;
import java.time.YearMonth;
import java.util.Collection;
import java.util.stream.Collectors;

public class DefaultPayoutSupplier extends BookingsPaymentDateRangeHandler {

    public static final double DEFAULT_PAYOUT_FACTOR = 1f;

    private static final Logger logger = LoggerFactory.getLogger(DefaultPayoutSupplier.class);

    /**
     * @see DefaultPayoutSupplier#applyPayoutFactor(MonetaryAmount, float)
     */
    public static MonetaryAmount applyPayoutFactor(final String amount, final double payoutFactor) {
	return applyPayoutFactor(Payments.createMondary(amount), payoutFactor);
    }

    /**
     * Applies the payout factor. Note that a negative amount will be increased by a
     * smaller payout factor.
     *
     * @param amount
     *            the amount to which the payout factor should be applied
     * @param payoutFactor
     *            the payout factor to apply
     * @return the adjusted payout
     */
    public static MonetaryAmount applyPayoutFactor(final MonetaryAmount amount, final double payoutFactor) {
	if (payoutFactor > 1) {
	    if (logger.isWarnEnabled()) {
		logger.warn("Payout above 100%");
	    }
	}
	// System.err.println("dd " + amount);
	final MonetaryAmount result = amount.multiply(payoutFactor);
	return result;
    }

    private final Collection<? extends CleaningEntry> cleanings;

    private final Collection<? extends ExpenseBean> commonExpenses;

    private double payoutFactor;

    public DefaultPayoutSupplier(final Range<LocalDate> dates, final Collection<? extends BookingBean> bookings,
	    final Collection<? extends CleaningEntry> cleanings,
	    final Collection<? extends ExpenseBean> commonExpenses) {
	this(dates, bookings, cleanings, commonExpenses, DEFAULT_PAYOUT_FACTOR);
    }

    public DefaultPayoutSupplier(final Range<LocalDate> dates, final Collection<? extends BookingBean> bookings,
	    final Collection<? extends CleaningEntry> cleanings, final Collection<? extends ExpenseBean> commonExpenses,
	    final double payoutFactor) {
	super(dates, bookings);
	this.cleanings = cleanings;
	this.commonExpenses = commonExpenses;
	this.payoutFactor = payoutFactor;
    }

    public DefaultPayoutSupplier(final YearMonth month, final Collection<? extends BookingBean> bookings,
	    final Collection<? extends CleaningEntry> cleanings,
	    final Collection<? extends ExpenseBean> commonExpenses) {
	this(month, bookings, cleanings, commonExpenses, DEFAULT_PAYOUT_FACTOR);
    }

    public DefaultPayoutSupplier(final YearMonth month, final Collection<? extends BookingBean> bookings,
	    final Collection<? extends CleaningEntry> cleanings, final Collection<? extends ExpenseBean> commonExpenses,
	    final double payoutFactor) {
	super(month, bookings);

	this.cleanings = cleanings;
	this.commonExpenses = commonExpenses;
	this.payoutFactor = payoutFactor;
    }

    public Collection<? extends CleaningEntry> getCleanings() {
	return cleanings;
    }

    public Collection<? extends ExpenseBean> getCommonExpenses() {
	return commonExpenses;
    }

    public MonetaryAmount getPayout(final BookingOrigin origin, final boolean cheat) {

	final BookingsByOrigin<BookingBean> bbo = new BookingsByOrigin<>(getBookings());

	// the total amount generated by this origin, including service fees and
	// cleaning fees
	final MonetaryAmount grossIncome = new DefaultGrossPaymentsSupplier(getDateRange())
		.apply(bbo.getByOrigin(origin));

	if (logger.isDebugEnabled()) {
	    logger.debug(origin + ": Gross income: " + grossIncome);
	}

	// the total amount of services for this origin
	final MonetaryAmount serviceFees = new DefaultServiceFeesSupplier(getDateRange())
		.apply(bbo.getByOrigin(origin));

	// all white cleaning costs that have been payed for this origin
	final MonetaryAmount cleaningCosts = Payments.getSum(CleaningExpensesFactory.build(getCleanings(), false)
		.stream().filter(e -> (e.getOrigin() != null) && e.getOrigin().equals(origin))
		.collect(Collectors.toList()));

	final MonetaryAmount commonExp = Payments.getSum(getCommonExpenses());
	if (logger.isDebugEnabled()) {
	    logger.debug(origin + ": Total common expenses: " + commonExp);
	}

	final MonetaryAmount fixedCostsAnteilig = new DefaultFixedCostsAnteilCalculator(getDateRange(), getBookings())
		.getFixkostenAnteil(origin, cheat, commonExp);

	if (logger.isDebugEnabled()) {
	    logger.debug(origin + ": Common expenses anteilig: " + fixedCostsAnteilig);
	}

	// service fees abziehen
	final MonetaryAmount grossIncomeMinusServiceFees = grossIncome.subtract(serviceFees);

	// Anteilige Fixkosten abziehen
	final MonetaryAmount grossIncomeMinusServiceFeesMinusFixedCostsAnteilig = grossIncomeMinusServiceFees
		.subtract(fixedCostsAnteilig);

	// Spezifische Kosten abziehen
	final MonetaryAmount grossIncomeMinusServiceFeesMinusFixedCostsAnteiligMinusCleaningCosts = grossIncomeMinusServiceFeesMinusFixedCostsAnteilig
		.subtract(cleaningCosts);

	final MonetaryAmount result3 = applyPayoutFactor(
		grossIncomeMinusServiceFeesMinusFixedCostsAnteiligMinusCleaningCosts, getPayoutFactor());

	if (logger.isDebugEnabled()) {
	    logger.debug(origin + ": Payout: " + result3);
	}

	return result3;
    }

    public MonetaryAmount getPayout(final String originName, final boolean cheat) {
	return getPayout(new BookingOrigin(originName), cheat);
    }

    public double getPayoutFactor() {
	return payoutFactor;
    }

    public DefaultPayoutSupplier setPayoutFactor(final double payoutFactor) {
	this.payoutFactor = payoutFactor;
	return this;
    }

}
